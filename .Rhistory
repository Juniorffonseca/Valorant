runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
?tabPanel
mpg
install.packages('DT')
install.packages("DT")
rsconnect::setAccountInfo(name='junin',
token='32EBEF951B8A56807245F0BE8E6CE1CB',
secret='<SECRET>')
library(rsconnect)
rsconnect::setAccountInfo(name='junin',
token='32EBEF951B8A56807245F0BE8E6CE1CB',
secret='<SECRET>')
rsconnect::setAccountInfo(name='junin',
token='32EBEF951B8A56807245F0BE8E6CE1CB',
secret='xWOGbLS78Cp/q6za61DHr5MVVQ3mJmbKUEgf3Qzv')
library(rsconnect)
rsconnect::deployApp('path/to/your/app')
library(rsconnect)
rsconnect::deployApp('/')
library(rsconnect)
rsconnect::deployApp('C:/Users/anonb/Documents/TCC Pós/Scripts')
n
library(rsconnect)
rsconnect::deployApp('C:/Users/anonb/Documents/TCC Pós/Scripts')
?link
?url
# Carregando pacotes -------------------------------------------------------------------------------------
library(dplyr)
library(tidyr)
library(rvest)
library(httr)
# Armazenando a url em uma variável -----------------------------------------------------------------------
link <- "https://www.vlr.gg/stats/?event_group_id=all&event_id=all&region=all&country=all&min_rounds=50&min_rating=1550&agent=all&map_id=all&timespan=all"
# Pegando os Dados no link -------------------------------------------------------------------------------
players <- read_html(link) %>%
html_node("table") %>%
html_table()
View(players)
# Separando time e jogador em duas colunas --------------------------------------------------------------
players <- separate(players, Player, into = c("Player", "Team"), sep = "\\s+", extra = "merge")
# Pegando os Dados no link -------------------------------------------------------------------------------
players <- read_html(link) %>%
html_node("table") %>%
html_table()
# Separando time e jogador em duas colunas --------------------------------------------------------------
players <- separate(players, Player, into = c("Player", "Team"), sep = "\\s+", extra = "merge") %>%
select('Player', 'Team', 'R', 'ACS', 'K:D', 'KAST', 'ADR')
# Carregando pacotes --------------------------------------------------------------------------------------
library(dplyr)
library(tidyr)
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(reshape2)
library(readr)
library(purrr)
# Criando variável páginas e criando variável 'p' que será a parte final do url (o número da página) -------
paginas <- ''
p <- 1
# Criando um laço for que armazenará o url de cada página dentro da variável paginas -----------------------
for (i in 1:33){
paginas[p] <- paste('https://www.vlr.gg/matches/results/?page=', p, sep = '')
p = p + 1
}
paginas
# Variável partidas e variável c ---------------------------------------------------------------------------
c <- 1
partidas <- 'a'
# Função que retorna o url de cada partida -----------------------------------------------------------------
funcaoPagina <- function(pagina){
partidas <- read_html(pagina) %>%
html_nodes('a') %>% html_attr('href') # Nessa parte ele pega todos os urls que estão contidos na página.
partidas <- partidas[15:64] # Aqui é separado os urls que são efetivamente de partidas.
n <- 1
for (i in partidas){
partidas[n] <- paste('https://www.vlr.gg', partidas[n], sep = '') # Salvando urls dentro da variável partida
n = n + 1
}
return(partidas)
}
# Carregando pacotes --------------------------------------------------------------------------------------
library(dplyr)
library(tidyr)
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
library(caret)
# Carregando o dataframe -----------------------------------------------------------------------------------
jogos <- read.csv2('csv/df.csv') %>% dplyr::select(-X)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(6)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
View(normalizando_test)
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
View(test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
s <- 1
while ( i < 0.7) {
acharseed(s)
s <- s + 1
}
while ( i < 0.7) {
acharseed(s)
s <- s + 1
}
while ( i < 0.75) {
acharseed(s)
s <- s + 1
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(6)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 2,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = T,
threshold = 2,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
View(predictVstest)
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
s <- 1
while ( i < 0.75) {
acharseed(s)
s <- s + 1
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(5)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = T,
threshold = 2,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(4)
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
View(training_data)
View(test_data)
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(4)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
s <- 1
while ( i < 0.8) {
acharseed(s)
s <- s + 1
}
while ( i < 0.77) {
acharseed(s)
s <- s + 1
}
# Atualizando a seed para achar a melhor neuralnetwork -------------------------------------------------------
set.seed(4264)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
normalizando_test <- dplyr::select(test_data, -ganhador)
normalizando_test <- as.data.frame(scale(normalizando_test))
test_data <- dplyr::select(test_data, ganhador)
test_data <- cbind(normalizando_test, test_data)
normalizando_training <- dplyr::select(training_data, -ganhador)
normalizando_training <- as.data.frame(scale(normalizando_training))
training_data <- dplyr::select(training_data, ganhador)
training_data <- cbind(normalizando_training, training_data)
training_data$ganhador <- as.factor(training_data$ganhador)
test_data$ganhador <- as.factor(test_data$ganhador)
acharnn <- function(){
n <- neuralnet(ganhador == 1 ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD +
time1ADR + time2ADR,
data = training_data,
hidden = c(10,10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.3,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 10000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>mean(Predict$net.result),1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.80) {
acharnn()
}
while ( i < 0.82) {
acharnn()
}
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
