timeB_R <- mean(timeB_df$R)
timeB_ACS <- mean(timeB_df$ACS)
timeB_KAST <- mean(timeB_df$KAST)
timeB_KD <- mean(timeB_df$K.D)
timeB_ADR <- mean(timeB_df$ADR)
partida <- c(timeA_R, timeB_R, timeA_ACS, timeB_ACS, timeA_KAST, timeB_KAST, timeA_KD, timeB_KD,
timeA_ADR, timeB_ADR)
jogos_scale <- read.csv2('csv/jogos.csv') %>% select(-X, -ganhador)
jogos_scale <- rbind(jogos_scale, partida)
jogos_scale <- scale(jogos_scale)
partida <- jogos_scale[141,]
partida <- t(partida)
partida <- as.data.frame(partida)
colnames(partida) <- c('timeA_R', 'timeB_R', 'timeA_ACS', 'timeB_ACS', 'timeA_KAST', 'timeB_KAST', 'timeA_KD', 'timeB_KD',
'timeA_ADR', 'timeB_ADR')
previsao <- compute(n, partida)
previsao$net.result
previsao <- previsao$net.result
a <- previsao[1]
b <- previsao[2]
transforma_positivo <- function (x){
y = atan(x) + pi/2
return (y)
}
transforma_probabilidade <- function (y, x){
z = y / (y + x)
w = x / (x + y)
c = as.matrix(c(z,w))
return(c)
}
a <- transforma_positivo(a)
b <- transforma_positivo(b)
previsao <- transforma_probabilidade(a,b)
return(previsao)
}
# Médias
timeA_R <- mean(timeA_df$R)
timeA_ACS <- mean(timeA_df$ACS)
timeA_KAST <- mean(timeA_df$KAST)
timeA_KD <- mean(timeA_df$K.D)
timeA_ADR <- mean(timeA_df$ADR)
timeB_R <- mean(timeB_df$R)
timeB_ACS <- mean(timeB_df$ACS)
timeB_KAST <- mean(timeB_df$KAST)
timeB_KD <- mean(timeB_df$K.D)
timeB_ADR <- mean(timeB_df$ADR)
partida <- c(timeA_R, timeB_R, timeA_ACS, timeB_ACS, timeA_KAST, timeB_KAST, timeA_KD, timeB_KD,
timeA_ADR, timeB_ADR)
jogos_scale <- read.csv2('csv/jogos.csv') %>% select(-X, -ganhador)
jogos_scale <- rbind(jogos_scale, partida)
jogos_scale <- scale(jogos_scale)
View(jogos_scale)
partida <- jogos_scale[141,]
partida <- t(partida)
partida <- as.data.frame(partida)
View(partida)
colnames(partida) <- c('timeA_R', 'timeB_R', 'timeA_ACS', 'timeB_ACS', 'timeA_KAST', 'timeB_KAST', 'timeA_KD', 'timeB_KD',
'timeA_ADR', 'timeB_ADR')
colnames(partida) <- c(time1R, time2R, time1ACS, time2ACS, time1KAST, time2KAST, time1KD, time2KD, time1ADR,
time2ADR, ganhador)
colnames(partida) <- c('time1R', 'time2R', 'time1ACS', 'time2ACS', 'time1KAST', 'time2KAST', 'time1KD', 'time2KD',
'time1ADR', 'time2ADR', 'ganhador')
colnames(partida) <- c('time1R', 'time2R', 'time1ACS', 'time2ACS', 'time1KAST', 'time2KAST', 'time1KD', 'time2KD',
'time1ADR', 'time2ADR')
previsao <- compute(n, partida)
runApp()
runApp()
View(info)
# Pegando os dados no link da partida ----------------------------------------------------------------------
info <- read_html('https://www.vlr.gg/130624/optic-gaming-vs-loud-valorant-champions-2022-group-stage-winners-b') %>%
html_nodes("table") %>%
html_table()
View(info)
library(dplyr)
library(tidyr)
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
# Carregando o dataframe -----------------------------------------------------------------------------------
jogos <- read.csv2('csv/jogos.csv') %>% dplyr::select(-X)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando <- dplyr::select(jogos, -ganhador)
normalizando <- as.data.frame(scale(normalizando))
jogos <- dplyr::select(jogos, ganhador)
jogos <- cbind(normalizando, jogos)
rm(normalizando)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(5)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.8, 0.2))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
sum(predictVstest$ganhador == nn2)/ nrow(test_data)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
n <- 1
while ( i < 0.7) {
acharseed(n)
n <- n + 1
}
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.8, 0.2))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
n <- 1
while ( i < 0.7) {
acharseed(n)
n <- n + 1
}
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.8, 0.2))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
n <- 1
while ( i < 0.7) {
acharseed(n)
n <- n + 1
}
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.8, 0.2))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10),
err.fct = "sse",
linear.output = F,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
n <- 1
while ( i < 0.7) {
acharseed(n)
n <- n + 1
}
n <- 100
while ( i < 0.7) {
acharseed(n)
n <- n + 1
}
acharseed <- function(seed){
set.seed(seed)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.8, 0.2))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.001,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
}
n <- 100
while ( i < 0.7) {
acharseed(n)
n <- n + 1
}
n <- 1
while ( i < 0.7) {
acharseed(n)
n <- n + 1
}
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(100)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.8, 0.2))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
sum(predictVstest$ganhador == nn2)/ nrow(test_data)
save(n, file ='model_nnet.rda')
shiny::runApp()
runApp()
library(dplyr)
library(tidyr)
library(rvest)
library(quantmod)
library(httr)
library(tibble)
library(stringr)
library(neuralnet)
while ( i < 0.8) {
acharnn()
}
acharnn <- function(){
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 100000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.8) {
acharnn()
}
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(100)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.8, 0.2))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
sum(predictVstest$ganhador == nn2)/ nrow(test_data)
acharnn <- function(){
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 100000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.8) {
acharnn()
}
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(100)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(6)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
acharnn <- function(){
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 100000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.8) {
acharnn()
}
acharnn <- function(){
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 100000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.8) {
acharnn()
}
load(n, file ='model_nnet.rda')
load(n, file ='model_nnet.rda')
load(file ='model_nnet.rda')
View(n)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
# Carregando o dataframe -----------------------------------------------------------------------------------
jogos <- read.csv2('csv/jogos.csv') %>% dplyr::select(-X)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando <- dplyr::select(jogos, -ganhador)
normalizando <- as.data.frame(scale(normalizando))
jogos <- dplyr::select(jogos, ganhador)
jogos <- cbind(normalizando, jogos)
rm(normalizando)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(6)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
Predict$net.result
View(test_data)
# Carregando o dataframe -----------------------------------------------------------------------------------
jogos <- read.csv2('csv/jogos.csv') %>% dplyr::select(-X)
# Normalizando os dados ------------------------------------------------------------------------------------
normalizando <- dplyr::select(jogos, -ganhador)
normalizando <- as.data.frame(scale(normalizando))
jogos <- dplyr::select(jogos, ganhador)
jogos <- cbind(normalizando, jogos)
rm(normalizando)
jogos$ganhador <- as.factor(jogos$ganhador)
# Criando dataframes de teste e validação -----------------------------------------------------------------
set.seed(6)
inp <- sample(2, nrow(jogos), replace = TRUE, prob = c(0.7, 0.3))
training_data <- jogos[inp==1, ]
test_data <- jogos[inp==2, ]
# Modelando a rede neural ---------------------------------------------------------------------------------
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 1000000)
# Prediction ---------------------------------------------------------------------------------------------
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
sum(predictVstest$ganhador == nn2)/ nrow(test_data)
Predict$net.result
acharnn <- function(){
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = F,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 100000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
while ( i < 0.8) {
acharnn()
}
acharnn <- function(){
n <- neuralnet(ganhador ~ time1R + time2R + time1ACS + time2ACS + time1KAST + time2KAST + time1KD + time2KD + time1ADR +
time2ADR,
data = training_data,
hidden = c(10,10),
err.fct = "sse",
linear.output = T,
threshold = 0.01,
lifesign = 'minimal',
rep = 1,
algorithm = 'rprop-',
stepmax = 100000)
Predict = compute(n, test_data)
nn2 <- ifelse(Predict$net.result[,1]>Predict$net.result[,2],1,0)
predictVstest <- cbind(test_data, Predict$net.result)
i <<- sum(predictVstest$ganhador == nn2)/ nrow(test_data)
print(i)
}
while ( i < 0.8) {
acharnn()
}
save(n, file ='model_nnet.rda')
runApp()
